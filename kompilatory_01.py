# -*- coding: utf-8 -*-
"""kompilatory_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NVNOXkwnyY9GIDWq8HVd06m__-OMkIzV

NUMBER	"NUMBER"	Liczba całkowita lub zmiennoprzecinkowa

IDENTIFIER	"IDENTIFIER"	Identyfikator (np. zmienne, nazwy funkcji)

OPERATOR	"OPERATOR"	Operator arytmetyczny + - * / %

COMPARISON	"COMPARISON"	Operator porównania == != < > <= >=

ASSIGNMENT	"ASSIGNMENT"	Operator przypisania =

LOGICAL	"LOGICAL"	Operator logiczny &&, !, ||

LPAREN	"LPAREN"	Lewy nawias (

RPAREN	"RPAREN"	Prawy nawias )

LBRACE	"LBRACE"	Lewa klamra {

RBRACE	"RBRACE"	Prawa klamra }

SEMICOLON	"SEMICOLON"	Średnik ;

COMMA	"COMMA"	Przecinek ,




dokończyć ten słownik z tokenami, zrobić ten skaner przynajmniej dla operator, LP, RP, NUMBER
"""

##

example_input = "2+3*(76+8/3)+ 3*(9-3)"

#funkcja do pomijania spacji
def clean_spaces(input):
  clean_input = ""
  for letter in input:
    if letter != " ":
      clean_input += letter
  return clean_input

#funkcja do sprawdzania czy char jest liczbą
def is_digit(char):
    return '0' <= char <= '9'

def is_letter(char):
    return 'a' <= char <= 'z'

#funkcja do sprawdzania czy token jest liczbą
"""def is_integer(token):
    if not is_digit(token[-1]):
        return False
    for char in token:
        if not is_digit(char):
            return False
    return True"""
def is_integer(lexeme):
    #if not lexeme[0] in ('-', '+') and not is_digit(lexeme[0]):
    if not is_digit(lexeme[0]):
        return False
    for l in lexeme[1:]:
        if not is_digit(l):
            return False
    return True

#funkcja do sprawdzania czy token należy do słów kluczowych
def is_ident(token):
    return token in ["def", "return", "if", "else"];

value = {"+": ("Operator", "Plus"),
         "-": ("Operator", "Minus"),
         "*" : ("Operator", "Mnozenie"),
         "/" : ("Operator", "Dzielenie"),
         "(" : ("LPAREN", "Lewy nawias"),
         ")" : ("RPAREN", "Prawy nawias"),
         "{" : ("LBRACE", "Lewa klamra"),
         "}" : ("RBRACE", "Prawa klamra"),
         "=" : ("ASSIGNMENT", "Operator przypisania"),
         "==" : ("COMPARISON", "Operator porównania"),
         "!=" : ("COMPARISON", "Operator różności"),
         "<" : ("COMPARISON", "Operator mniejszości"),
         ">" : ("COMPARISON", "Operator większości"),
         "<=" : ("COMPARISON", "Operator mniejszości równości"),
         ">=" : ("COMPARISON", "Operator większości równości"),
         "&&" : ("LOGICAL", "Operator logiczny and"),
         "||" : ("LOGICAL", "Operator logiczny or")}

def is_token(lexeme, letter_ind):
  if lexeme in value:
    (t1, t2) = value[lexeme]
    return [t1, t2, letter_ind]
  else:
    #return - zależy czy liczba, czy identyfikator?
    if is_integer(lexeme):
      return ["NUMBER", lexeme, letter_ind]
    if is_ident(lexeme):
      return ["IDENTIFIER", lexeme, letter_ind]

def scanner(line, p):
  if p == len(line) - 1:
    if is_token(line[p], p) is not None:
      return is_token(line[p], p + 1)
    else:
      #jak nie jest ani operatorem ani liczbą ani identifier to zwroc komunikat błędu
      return ["ERROR", line[p], p + 1]
  token_builder = ""
  token = False
  for letter_ind in range(p, len(line)):
    if (token_builder + line[letter_ind]) not in value and not (is_integer(token_builder + line[letter_ind]) or is_ident(token_builder + line[letter_ind])) and token:
      if is_token(token_builder, letter_ind) is not None:
        return is_token(token_builder, letter_ind)

    elif letter_ind < len(line):
      token_builder += line[letter_ind]
      if letter_ind == len(line) - 1 and not token and (is_token(token_builder + line[letter_ind], letter_ind) in (None, False)):
        #jak nie jest ani operatorem ani liczbą ani identifier to zwroc komunikat błędu
        return ["ERROR", token_builder, letter_ind + 1]
    else:
      #jak nie jest ani operatorem ani liczbą ani identifier to zwroc komunikat błędu
      return ["ERROR", token_builder, letter_ind]

    if token_builder in value or (is_integer(token_builder) or is_ident(token_builder)):
      token = True

# z stdin tak jak powinno być
from sys import stdin

for line in stdin:
  line = clean_spaces(line)
  p = 0
  while p < len(line):
    kwp = scanner(line, p) # k - klucz, w- wartość, p - indeks początku skanowania linii
    print("   ", kwp[0], kwp[1])
    p = kwp[2]

#nie z stdin tylko z zdefiniowamego stringa

line = clean_spaces(example_input)
p = 0
while p < len(line):
  kwp = scanner(line, p) #k - klucz w- wartość
  print("   ", kwp[0], kwp[1])
  p = kwp[2]