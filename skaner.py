# -*- coding: utf-8 -*-
"""kompilatory_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NVNOXkwnyY9GIDWq8HVd06m__-OMkIzV

NUMBER	"NUMBER"	Liczba całkowita lub zmiennoprzecinkowa

IDENTIFIER	"IDENTIFIER"	Identyfikator (np. zmienne, nazwy funkcji)

OPERATOR	"OPERATOR"	Operator arytmetyczny + - * / %

COMPARISON	"COMPARISON"	Operator porównania == != < > <= >=

ASSIGNMENT	"ASSIGNMENT"	Operator przypisania =

LOGICAL	"LOGICAL"	Operator logiczny &&, !, ||

LPAREN	"LPAREN"	Lewy nawias (

RPAREN	"RPAREN"	Prawy nawias )

LBRACE	"LBRACE"	Lewa klamra {

RBRACE	"RBRACE"	Prawa klamra }

SEMICOLON	"SEMICOLON"	Średnik ;

COMMA	"COMMA"	Przecinek ,




dokończyć ten słownik z tokenami, zrobić ten skaner przynajmniej dla operator, LP, RP, NUMBER
"""

##

example_input = "2+3*(76+8/3)+ a3*(9-3)"

#funkcja do pomijania spacji
def clean_spaces(input):
  clean_input = ""
  for letter in input:
    if letter != " ":
      clean_input += letter
  return clean_input

#funkcja do sprawdzania czy char jest liczbą
def is_digit(char):
    return '0' <= char <= '9'

def is_letter(char):
    return 'a' <= char <= 'z'

#funkcja do sprawdzania czy token jest liczbą
"""def is_integer(token):
    if not is_digit(token[-1]):
        return False
    for char in token:
        if not is_digit(char):
            return False
    return True"""
def is_integer(line, start, end):
    if not is_digit(line[start]):
      if line[start] in ('+', '-'):
        if start > 0:
          if line[start - 1] not in ('(', '/'):
            return False
      else:
        return False
    for l in line[start + 1 : end + 1]:
      if not is_digit(l):
          return False
    return True

#funkcja do sprawdzania czy token należy do słów kluczowych
def is_keyword(token):
    return token in ["def", "return", "if", "else"]

value = {"+": ("Operator", "+"),
         "-": ("Operator", "-"),
         "*" : ("Operator", "*"),
         "/" : ("Operator", "/"),
         "(" : ("LPAREN", "("),
         ")" : ("RPAREN", ")"),
         "{" : ("LBRACE", "{"),
         "}" : ("RBRACE", "}"),
         "=" : ("ASSIGNMENT", "="),
         "==" : ("COMPARISON", "=="),
         "!=" : ("COMPARISON", "!="),
         "<" : ("COMPARISON", "<"),
         ">" : ("COMPARISON", ">"),
         "<=" : ("COMPARISON", "<="),
         ">=" : ("COMPARISON", ">="),
         "&&" : ("LOGICAL", "&&"),
         "||" : ("LOGICAL", "||")}

def is_token(line, start, end, letter_ind):
  if line[start : end + 1] in value:
    (t1, t2) = value[line[start : end + 1]]
    return [t1, t2, letter_ind]
  else:
    #return - zależy czy liczba, czy identyfikator?
    if is_integer(line, start, end):
      return ["NUMBER", line[start : end + 1], letter_ind]
    if is_keyword(line[start : end + 1]):
      return ["IDENTIFIER", line[start : end + 1], letter_ind]

def scanner(line, p):
  if p == len(line) - 1:
    if is_token(line, p, p, p) is not None:
      return is_token(line, p, p, p + 1)
    else:
      #jak nie jest ani operatorem ani liczbą ani identifier to zwroc komunikat błędu
      return [f"ERROR in column {p}", line[p], p + 1]
  token_builder = ""
  token = False
  for letter_ind in range(p, len(line)):
    if (token_builder + line[letter_ind]) not in value and not (is_integer(line, p, letter_ind) or is_keyword(token_builder + line[letter_ind])) and token:
      if is_token(line, p, letter_ind - 1, letter_ind) is not None:
        return is_token(line, p, letter_ind - 1, letter_ind)
      else:
        #jak nie jest ani operatorem ani liczbą ani identifier to zwroc komunikat błędu
        return [f"ERROR in column {p}", token_builder, letter_ind]

    elif letter_ind < len(line):
      token_builder += line[letter_ind]
      if letter_ind == len(line) - 1 and not token and (is_token(line, p, letter_ind, letter_ind) in (None, False)):
        #jak nie jest ani operatorem ani liczbą ani identifier to zwroc komunikat błędu
        return [f"ERROR in column {p}", token_builder, letter_ind + 1]
    else:
      #jak nie jest ani operatorem ani liczbą ani identifier to zwroc komunikat błędu
      return [f"ERROR in column {p}", token_builder, letter_ind]

    if len(token_builder) > 0:
      if token_builder in value or (is_integer(line, p, letter_ind) or is_keyword(token_builder)):
        token = True

# z stdin tak jak powinno być
from sys import stdin

"""for line in stdin:
  line = clean_spaces(line)
  p = 0
  while p < len(line):
    kwp = scanner(line, p) # k - klucz, w- wartość, p - indeks początku skanowania linii
    print("   ", kwp[0], kwp[1])
    p = kwp[2]"""

#nie z stdin tylko z zdefiniowanego stringa

line = clean_spaces(example_input)
p = 0
while p < len(line):
  kwp = scanner(line, p) #k - klucz w- wartość
  print("   ", kwp[0], kwp[1])
  p = kwp[2]